<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/network/qhttp.cpp:1010 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TQHttp Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>TQHttp Class Reference<br><small>[<a href="network.html">network module</a>]</small></h1>

<p>The TQHttp class provides an implementation of the HTTP protocol.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qhttp-h.html">ntqhttp.h</a>&gt;</tt>
<p>Inherits <a href="ntqnetworkprotocol.html">TQNetworkProtocol</a>.
<p><a href="qhttp-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn><a href="#TQHttp"><b>TQHttp</b></a> ()</li>
<li class=fn><a href="#TQHttp-2"><b>TQHttp</b></a> ( TQObject&nbsp;*&nbsp;parent, const&nbsp;char&nbsp;*&nbsp;name = 0 )</li>
<li class=fn><a href="#TQHttp-3"><b>TQHttp</b></a> ( const&nbsp;TQString&nbsp;&amp;&nbsp;hostname, TQ_UINT16&nbsp;port = 80, TQObject&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0 )</li>
<li class=fn>virtual <a href="#~TQHttp"><b>~TQHttp</b></a> ()</li>
<li class=fn>enum <a href="#State-enum"><b>State</b></a> { Unconnected, HostLookup, Connecting, Sending, Reading, Connected, Closing }</li>
<li class=fn>enum <a href="#Error-enum"><b>Error</b></a> { NoError, UnknownError, HostNotFound, ConnectionRefused, UnexpectedClose, InvalidResponseHeader, WrongContentLength, Aborted }</li>
<li class=fn>int <a href="#setHost"><b>setHost</b></a> ( const&nbsp;TQString&nbsp;&amp;&nbsp;hostname, TQ_UINT16&nbsp;port = 80 )</li>
<li class=fn>int <a href="#get"><b>get</b></a> ( const&nbsp;TQString&nbsp;&amp;&nbsp;path, TQIODevice&nbsp;*&nbsp;to = 0 )</li>
<li class=fn>int <a href="#post"><b>post</b></a> ( const&nbsp;TQString&nbsp;&amp;&nbsp;path, TQIODevice&nbsp;*&nbsp;data, TQIODevice&nbsp;*&nbsp;to = 0 )</li>
<li class=fn>int <a href="#post-2"><b>post</b></a> ( const&nbsp;TQString&nbsp;&amp;&nbsp;path, const&nbsp;TQByteArray&nbsp;&amp;&nbsp;data, TQIODevice&nbsp;*&nbsp;to = 0 )</li>
<li class=fn>int <a href="#head"><b>head</b></a> ( const&nbsp;TQString&nbsp;&amp;&nbsp;path )</li>
<li class=fn>int <a href="#request"><b>request</b></a> ( const&nbsp;TQHttpRequestHeader&nbsp;&amp;&nbsp;header, TQIODevice&nbsp;*&nbsp;data = 0, TQIODevice&nbsp;*&nbsp;to = 0 )</li>
<li class=fn>int <a href="#request-2"><b>request</b></a> ( const&nbsp;TQHttpRequestHeader&nbsp;&amp;&nbsp;header, const&nbsp;TQByteArray&nbsp;&amp;&nbsp;data, TQIODevice&nbsp;*&nbsp;to = 0 )</li>
<li class=fn>int <a href="#closeConnection"><b>closeConnection</b></a> ()</li>
<li class=fn>TQ_ULONG <a href="#bytesAvailable"><b>bytesAvailable</b></a> () const</li>
<li class=fn>TQ_LONG <a href="#readBlock"><b>readBlock</b></a> ( char&nbsp;*&nbsp;data, TQ_ULONG&nbsp;maxlen )</li>
<li class=fn>TQByteArray <a href="#readAll"><b>readAll</b></a> ()</li>
<li class=fn>int <a href="#currentId"><b>currentId</b></a> () const</li>
<li class=fn>TQIODevice * <a href="#currentSourceDevice"><b>currentSourceDevice</b></a> () const</li>
<li class=fn>TQIODevice * <a href="#currentDestinationDevice"><b>currentDestinationDevice</b></a> () const</li>
<li class=fn>TQHttpRequestHeader <a href="#currentRequest"><b>currentRequest</b></a> () const</li>
<li class=fn>bool <a href="#hasPendingRequests"><b>hasPendingRequests</b></a> () const</li>
<li class=fn>void <a href="#clearPendingRequests"><b>clearPendingRequests</b></a> ()</li>
<li class=fn>State <a href="#state"><b>state</b></a> () const</li>
<li class=fn>Error <a href="#error"><b>error</b></a> () const</li>
<li class=fn>TQString <a href="#errorString"><b>errorString</b></a> () const</li>
</ul>
<h2>Public Slots</h2>
<ul>
<li class=fn>void <a href="#abort"><b>abort</b></a> ()</li>
</ul>
<h2>Signals</h2>
<ul>
<li class=fn>void <a href="#stateChanged"><b>stateChanged</b></a> ( int&nbsp;state )</li>
<li class=fn>void <a href="#responseHeaderReceived"><b>responseHeaderReceived</b></a> ( const&nbsp;TQHttpResponseHeader&nbsp;&amp;&nbsp;resp )</li>
<li class=fn>void <a href="#readyRead"><b>readyRead</b></a> ( const&nbsp;TQHttpResponseHeader&nbsp;&amp;&nbsp;resp )</li>
<li class=fn>void <a href="#dataSendProgress"><b>dataSendProgress</b></a> ( int&nbsp;done, int&nbsp;total )</li>
<li class=fn>void <a href="#dataReadProgress"><b>dataReadProgress</b></a> ( int&nbsp;done, int&nbsp;total )</li>
<li class=fn>void <a href="#requestStarted"><b>requestStarted</b></a> ( int&nbsp;id )</li>
<li class=fn>void <a href="#requestFinished"><b>requestFinished</b></a> ( int&nbsp;id, bool&nbsp;error )</li>
<li class=fn>void <a href="#done"><b>done</b></a> ( bool&nbsp;error )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The TQHttp class provides an implementation of the HTTP protocol.

<p> 

<p> This class provides two different interfaces: one is the
<a href="ntqnetworkprotocol.html">TQNetworkProtocol</a> interface that allows you to use HTTP through the
<a href="ntqurloperator.html">TQUrlOperator</a> abstraction. The other is a direct interface to HTTP
that allows you to have more control over the requests and that
allows you to access the response header fields.
<p> Don't mix the two interfaces, since the behavior is not
well-defined.
<p> If you want to use TQHttp with the TQNetworkProtocol interface, you
do not use it directly, but rather through a TQUrlOperator, for
example:
<p> <pre>
    <a href="ntqurloperator.html">TQUrlOperator</a> op( "http://www.trolltech.com" );
    op.<a href="ntqurloperator.html#get">get</a>( "index.html" );
    </pre>
 
<p> This code will only work if the TQHttp class is registered; to
register the class, you must call <a href="ntqurloperator.html#qInitNetworkProtocols">tqInitNetworkProtocols</a>() before
using a TQUrlOperator with HTTP.
<p> The TQNetworkProtocol interface for HTTP only supports the
operations <a href="ntqnetworkprotocol.html#operationGet">operationGet</a>() and <a href="ntqnetworkprotocol.html#operationPut">operationPut</a>(), i.e.
<a href="ntqurloperator.html#get">TQUrlOperator::get</a>() and <a href="ntqurloperator.html#put">TQUrlOperator::put</a>(), if you use it with a
<a href="ntqurloperator.html">TQUrlOperator</a>.
<p> The rest of this descrption describes the direct interface to
HTTP.
<p> The class works asynchronously, so there are no blocking
functions. If an operation cannot be executed immediately, the
function will still return straight away and the operation will be
scheduled for later execution. The results of scheduled operations
are reported via signals. This approach depends on the event loop
being in operation.
<p> The operations that can be scheduled (they are called "requests"
in the rest of the documentation) are the following: <a href="#setHost">setHost</a>(),
<a href="#get">get</a>(), <a href="#post">post</a>(), <a href="#head">head</a>() and <a href="#request">request</a>().
<p> All of these requests return a unique identifier that allows you
to keep track of the request that is currently executed. When the
execution of a request starts, the <a href="#requestStarted">requestStarted</a>() signal with
the identifier is emitted and when the request is finished, the
<a href="#requestFinished">requestFinished</a>() signal is emitted with the identifier and a bool
that indicates if the request finished with an error.
<p> To make an HTTP request you must set up suitable HTTP headers. The
following example demonstrates, how to request the main HTML page
from the Trolltech home page (i.e. the URL
http://www.trolltech.com/index.html):
<p> <pre>
    <a href="qhttprequestheader.html">TQHttpRequestHeader</a> header( "GET", "/index.html" );
    header.<a href="qhttpheader.html#setValue">setValue</a>( "Host", "www.trolltech.com" );
    http-&gt;setHost( "www.trolltech.com" );
    http-&gt;request( header );
    </pre>
 
<p> For the common HTTP requests <tt>GET</tt>, <tt>POST</tt> and <tt>HEAD</tt>, TQHttp
provides the convenience functions <a href="#get">get</a>(), <a href="#post">post</a>() and <a href="#head">head</a>(). They
already use a reasonable header and if you don't have to set
special header fields, they are easier to use. The above example
can also be written as:
<p> <pre>
    http-&gt;setHost( "www.trolltech.com" ); // id == 1
    http-&gt;get( "/index.html" );           // id == 2
    </pre>
 
<p> For this example the following sequence of signals is emitted
(with small variations, depending on network traffic, etc.):
<p> <pre>
    <a href="#requestStarted">requestStarted</a>( 1 )
    <a href="#requestFinished">requestFinished</a>( 1, FALSE )

    <a href="#requestStarted">requestStarted</a>( 2 )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">Connecting</a> )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">Sending</a> )
    <a href="#dataSendProgress">dataSendProgress</a>( 77, 77 )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">Reading</a> )
    <a href="#responseHeaderReceived">responseHeaderReceived</a>( responseheader )
    <a href="#dataReadProgress">dataReadProgress</a>( 5388, 0 )
    <a href="#readyRead">readyRead</a>( responseheader )
    <a href="#dataReadProgress">dataReadProgress</a>( 18300, 0 )
    <a href="#readyRead">readyRead</a>( responseheader )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">Connected</a> )
    <a href="#requestFinished">requestFinished</a>( 2, FALSE )

    <a href="#done">done</a>( FALSE )

    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">Closing</a> )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">Unconnected</a> )
    </pre>
 
<p> The <a href="#dataSendProgress">dataSendProgress</a>() and <a href="#dataReadProgress">dataReadProgress</a>() signals in the above
example are useful if you want to show a <a href="ntqprogressbar.html">progressbar</a> to inform the user about the progress of the
download. The second argument is the total size of data. In
certain cases it is not possible to know the total amount in
advance, in which case the second argument is 0. (If you connect
to a <a href="ntqprogressbar.html">TQProgressBar</a> a total of 0 results in a busy indicator.)
<p> When the response header is read, it is reported with the
<a href="#responseHeaderReceived">responseHeaderReceived</a>() signal.
<p> The <a href="#readyRead">readyRead</a>() signal tells you that there is data ready to be
read. The amount of data can then be queried with the
<a href="#bytesAvailable">bytesAvailable</a>() function and it can be read with the <a href="#readBlock">readBlock</a>()
or <a href="#readAll">readAll</a>() functions.
<p> If an error occurs during the execution of one of the commands in
a sequence of commands, all the pending commands (i.e. scheduled,
but not yet executed commands) are cleared and no signals are
emitted for them.
<p> For example, if you have the following sequence of reqeusts
<p> <pre>
    http-&gt;setHost( "www.foo.bar" );       // id == 1
    http-&gt;get( "/index.html" );           // id == 2
    http-&gt;post( "register.html", data );  // id == 3
    </pre>
 
<p> and the <a href="#get">get</a>() request fails because the host lookup fails, then
the <a href="#post">post</a>() request is never executed and the signals would look
like this:
<p> <pre>
    <a href="#requestStarted">requestStarted</a>( 1 )
    <a href="#requestFinished">requestFinished</a>( 1, FALSE )

    <a href="#requestStarted">requestStarted</a>( 2 )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">HostLookup</a> )
    <a href="#requestFinished">requestFinished</a>( 2, TRUE )

    <a href="#done">done</a>( TRUE )

    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">Unconnected</a> )
    </pre>
 
<p> You can then get details about the error with the <a href="#error">error</a>() and
<a href="#errorString">errorString</a>() functions. Note that only unexpected behaviour, like
network failure is considered as an error. If the server response
contains an error status, like a 404 response, this is reported as
a normal response case. So you should always check the <a href="qhttpresponseheader.html#statusCode">status code</a> of the
response header.
<p> The functions <a href="#currentId">currentId</a>() and <a href="#currentRequest">currentRequest</a>() provide more
information about the currently executing request.
<p> The functions <a href="#hasPendingRequests">hasPendingRequests</a>() and <a href="#clearPendingRequests">clearPendingRequests</a>()
allow you to query and clear the list of pending requests.
<p> <p>See also <a href="network.html">TQt Network Documentation</a>, <a href="ntqnetworkprotocol.html">TQNetworkProtocol</a>, <a href="ntqurloperator.html">TQUrlOperator</a>, <a href="ntqftp.html">TQFtp</a>, and <a href="io.html">Input/Output and Networking</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="Error-enum"></a>TQHttp::Error</h3>  
<p> This enum identifies the error that occurred.
<ul>
<li><tt>TQHttp::NoError</tt> - No error occurred.
<li><tt>TQHttp::HostNotFound</tt> - The host name lookup failed.
<li><tt>TQHttp::ConnectionRefused</tt> - The server refused the connection.
<li><tt>TQHttp::UnexpectedClose</tt> - The server closed the connection unexpectedly.
<li><tt>TQHttp::InvalidResponseHeader</tt> - The server sent an invalid response header.
<li><tt>TQHttp::WrongContentLength</tt> - The client could not read the content correctly
because an error with respect to the content length occurred.
<li><tt>TQHttp::Aborted</tt> - The request was aborted with <a href="#abort">abort</a>().
<li><tt>TQHttp::UnknownError</tt> - An error other than those specified above
occurred.
</ul><p> <p>See also <a href="#error">error</a>().

<h3 class=fn><a name="State-enum"></a>TQHttp::State</h3>

<p> This enum is used to specify the state the client is in:
<ul>
<li><tt>TQHttp::Unconnected</tt> - There is no connection to the host.
<li><tt>TQHttp::HostLookup</tt> - A host name lookup is in progress.
<li><tt>TQHttp::Connecting</tt> - An attempt to connect to the host is in progress.
<li><tt>TQHttp::Sending</tt> - The client is sending its request to the server.
<li><tt>TQHttp::Reading</tt> - The client's request has been sent and the client
is reading the server's response.
<li><tt>TQHttp::Connected</tt> - The connection to the host is open, but the client is
neither sending a request, nor waiting for a response.
<li><tt>TQHttp::Closing</tt> - The connection is closing down, but is not yet
closed. (The state will be <a href="#State-enum">Unconnected</a> when the connection is
closed.)
</ul><p> <p>See also <a href="#stateChanged">stateChanged</a>() and <a href="#state">state</a>().

<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="TQHttp"></a>TQHttp::TQHttp ()
</h3>
Constructs a TQHttp object.

<h3 class=fn><a name="TQHttp-2"></a>TQHttp::TQHttp ( <a href="ntqobject.html">TQObject</a>&nbsp;*&nbsp;parent, const&nbsp;char&nbsp;*&nbsp;name = 0 )
</h3>
Constructs a TQHttp object. The parameters <em>parent</em> and <em>name</em>
are passed on to the <a href="ntqobject.html">TQObject</a> constructor.

<h3 class=fn><a name="TQHttp-3"></a>TQHttp::TQHttp ( const&nbsp;<a href="ntqstring.html">TQString</a>&nbsp;&amp;&nbsp;hostname, TQ_UINT16&nbsp;port = 80, <a href="ntqobject.html">TQObject</a>&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0 )
</h3>
Constructs a TQHttp object. Subsequent requests are done by
connecting to the server <em>hostname</em> on port <em>port</em>. The
parameters <em>parent</em> and <em>name</em> are passed on to the <a href="ntqobject.html">TQObject</a>
constructor.
<p> <p>See also <a href="#setHost">setHost</a>().

<h3 class=fn><a name="~TQHttp"></a>TQHttp::~TQHttp ()<tt> [virtual]</tt>
</h3>
Destroys the TQHttp object. If there is an open connection, it is
closed.

<h3 class=fn>void <a name="abort"></a>TQHttp::abort ()<tt> [slot]</tt>
</h3>
Aborts the current request and deletes all scheduled requests.
<p> For the current request, the <a href="#requestFinished">requestFinished</a>() signal with the <tt>error</tt> argument <tt>TRUE</tt> is emitted. For all other requests that are
affected by the <a href="#abort">abort</a>(), no signals are emitted.
<p> Since this slot also deletes the scheduled requests, there are no
requests left and the <a href="#done">done</a>() signal is emitted (with the <tt>error</tt>
argument <tt>TRUE</tt>).
<p> <p>See also <a href="#clearPendingRequests">clearPendingRequests</a>().

<h3 class=fn>TQ_ULONG <a name="bytesAvailable"></a>TQHttp::bytesAvailable () const
</h3>
Returns the number of bytes that can be read from the response
content at the moment.
<p> <p>See also <a href="#get">get</a>(), <a href="#post">post</a>(), <a href="#request">request</a>(), <a href="#readyRead">readyRead</a>(), <a href="#readBlock">readBlock</a>(), and <a href="#readAll">readAll</a>().

<h3 class=fn>void <a name="clearPendingRequests"></a>TQHttp::clearPendingRequests ()
</h3>
Deletes all pending requests from the list of scheduled requests.
This does not affect the request that is being executed. If
you want to stop this this as well, use <a href="#abort">abort</a>().
<p> <p>See also <a href="#hasPendingRequests">hasPendingRequests</a>() and <a href="#abort">abort</a>().

<h3 class=fn>int <a name="closeConnection"></a>TQHttp::closeConnection ()
</h3>
Closes the connection; this is useful if you have a keep-alive
connection and want to close it.
<p> For the requests issued with <a href="#get">get</a>(), <a href="#post">post</a>() and <a href="#head">head</a>(), TQHttp sets
the connection to be keep-alive. You can also do this using the
header you pass to the <a href="#request">request</a>() function. TQHttp only closes the
connection to the HTTP server if the response header requires it
to do so.
<p> The function does not block and returns immediately. The request
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#requestStarted">requestStarted</a>() and <a href="#requestFinished">requestFinished</a>().
<p> When the request is started the requestStarted() signal is
emitted. When it is finished the requestFinished() signal is
emitted.
<p> If you want to close the connection immediately, you have to use
<a href="#abort">abort</a>() instead.
<p> <p>See also <a href="#stateChanged">stateChanged</a>(), <a href="#abort">abort</a>(), <a href="#requestStarted">requestStarted</a>(), <a href="#requestFinished">requestFinished</a>(), and <a href="#done">done</a>().

<h3 class=fn><a href="ntqiodevice.html">TQIODevice</a>&nbsp;* <a name="currentDestinationDevice"></a>TQHttp::currentDestinationDevice () const
</h3>
Returns the <a href="ntqiodevice.html">TQIODevice</a> pointer that is used as to store the data of the HTTP
request being executed. If there is no current request or if the request
does not store the data to an IO device, this function returns 0.
<p> This function can be used to delete the TQIODevice in the slot connected to
the <a href="#requestFinished">requestFinished</a>() signal.
<p> <p>See also <a href="#get">get</a>(), <a href="#post">post</a>(), and <a href="#request">request</a>().

<h3 class=fn>int <a name="currentId"></a>TQHttp::currentId () const
</h3>
Returns the identifier of the HTTP request being executed or 0 if
there is no request being executed (i.e. they've all finished).
<p> <p>See also <a href="#currentRequest">currentRequest</a>().

<h3 class=fn><a href="qhttprequestheader.html">TQHttpRequestHeader</a> <a name="currentRequest"></a>TQHttp::currentRequest () const
</h3>
Returns the request header of the HTTP request being executed. If
the request is one issued by <a href="#setHost">setHost</a>() or <a href="#closeConnection">closeConnection</a>(), it
returns an invalid request header, i.e.
<a href="qhttpheader.html#isValid">TQHttpRequestHeader::isValid</a>() returns FALSE.
<p> <p>See also <a href="#currentId">currentId</a>().

<h3 class=fn><a href="ntqiodevice.html">TQIODevice</a>&nbsp;* <a name="currentSourceDevice"></a>TQHttp::currentSourceDevice () const
</h3>
Returns the <a href="ntqiodevice.html">TQIODevice</a> pointer that is used as the data source of the HTTP
request being executed. If there is no current request or if the request
does not use an IO device as the data source, this function returns 0.
<p> This function can be used to delete the TQIODevice in the slot connected to
the <a href="#requestFinished">requestFinished</a>() signal.
<p> <p>See also <a href="#currentDestinationDevice">currentDestinationDevice</a>(), <a href="#post">post</a>(), and <a href="#request">request</a>().

<h3 class=fn>void <a name="dataReadProgress"></a>TQHttp::dataReadProgress ( int&nbsp;done, int&nbsp;total )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when this object reads data from a HTTP
server to indicate the current progress of the download.
<p> <em>done</em> is the amount of data that has already arrived and <em>total</em> is the total amount of data. It is possible that the total
amount of data that should be transferred cannot be determined, in
which case <em>total</em> is 0.(If you connect to a <a href="ntqprogressbar.html">TQProgressBar</a>, the
progress bar shows a busy indicator if the total is 0).
<p> <b>Warning:</b> <em>done</em> and <em>total</em> are not necessarily the size in
bytes, since for large files these values might need to be
"scaled" to avoid overflow.
<p> <p>See also <a href="#dataSendProgress">dataSendProgress</a>(), <a href="#get">get</a>(), <a href="#post">post</a>(), <a href="#request">request</a>(), and <a href="ntqprogressbar.html#progress-prop">TQProgressBar::progress</a>.

<h3 class=fn>void <a name="dataSendProgress"></a>TQHttp::dataSendProgress ( int&nbsp;done, int&nbsp;total )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when this object sends data to a HTTP
server to inform it about the progress of the upload.
<p> <em>done</em> is the amount of data that has already arrived and <em>total</em> is the total amount of data. It is possible that the total
amount of data that should be transferred cannot be determined, in
which case <em>total</em> is 0.(If you connect to a <a href="ntqprogressbar.html">TQProgressBar</a>, the
progress bar shows a busy indicator if the total is 0).
<p> <b>Warning:</b> <em>done</em> and <em>total</em> are not necessarily the size in
bytes, since for large files these values might need to be
"scaled" to avoid overflow.
<p> <p>See also <a href="#dataReadProgress">dataReadProgress</a>(), <a href="#post">post</a>(), <a href="#request">request</a>(), and <a href="ntqprogressbar.html#progress-prop">TQProgressBar::progress</a>.

<h3 class=fn>void <a name="done"></a>TQHttp::done ( bool&nbsp;error )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when the last pending request has finished;
(it is emitted after the last request's <a href="#requestFinished">requestFinished</a>() signal).
<em>error</em> is TRUE if an error occurred during the processing;
otherwise <em>error</em> is FALSE.
<p> <p>See also <a href="#requestFinished">requestFinished</a>(), <a href="#error">error</a>(), and <a href="#errorString">errorString</a>().

<h3 class=fn><a href="ntqhttp.html#Error-enum">Error</a> <a name="error"></a>TQHttp::error () const
</h3>
Returns the last error that occurred. This is useful to find out
what happened when receiving a <a href="#requestFinished">requestFinished</a>() or a <a href="#done">done</a>()
signal with the <tt>error</tt> argument <tt>TRUE</tt>.
<p> If you start a new request, the error status is reset to <a href="#Error-enum">NoError</a>.

<h3 class=fn><a href="ntqstring.html">TQString</a> <a name="errorString"></a>TQHttp::errorString () const
</h3>
Returns a human-readable description of the last error that
occurred. This is useful to present a error message to the user
when receiving a <a href="#requestFinished">requestFinished</a>() or a <a href="#done">done</a>() signal with the <tt>error</tt> argument <tt>TRUE</tt>.

<h3 class=fn>int <a name="get"></a>TQHttp::get ( const&nbsp;<a href="ntqstring.html">TQString</a>&nbsp;&amp;&nbsp;path, <a href="ntqiodevice.html">TQIODevice</a>&nbsp;*&nbsp;to = 0 )
</h3>
Sends a get request for <em>path</em> to the server set by <a href="#setHost">setHost</a>() or
as specified in the constructor.
<p> <em>path</em> must be an absolute path like <tt>/index.html</tt> or an
absolute URI like <a href="http://www.trolltech.com/index.html">http://www.trolltech.com/index.html</a>.
<p> If the IO device <em>to</em> is 0 the <a href="#readyRead">readyRead</a>() signal is emitted
every time new content data is available to read.
<p> If the IO device <em>to</em> is not 0, the content data of the response
is written directly to the device. Make sure that the <em>to</em>
pointer is valid for the duration of the operation (it is safe to
delete it when the <a href="#requestFinished">requestFinished</a>() signal is emitted).
<p> The function does not block and returns immediately. The request
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#requestStarted">requestStarted</a>() and requestFinished().
<p> When the request is started the requestStarted() signal is
emitted. When it is finished the requestFinished() signal is
emitted.
<p> <p>See also <a href="#setHost">setHost</a>(), <a href="#post">post</a>(), <a href="#head">head</a>(), <a href="#request">request</a>(), <a href="#requestStarted">requestStarted</a>(), <a href="#requestFinished">requestFinished</a>(), and <a href="#done">done</a>().

<h3 class=fn>bool <a name="hasPendingRequests"></a>TQHttp::hasPendingRequests () const
</h3>
Returns TRUE if there are any requests scheduled that have not yet
been executed; otherwise returns FALSE.
<p> The request that is being executed is <em>not</em> considered as a
scheduled request.
<p> <p>See also <a href="#clearPendingRequests">clearPendingRequests</a>(), <a href="#currentId">currentId</a>(), and <a href="#currentRequest">currentRequest</a>().

<h3 class=fn>int <a name="head"></a>TQHttp::head ( const&nbsp;<a href="ntqstring.html">TQString</a>&nbsp;&amp;&nbsp;path )
</h3>
Sends a header request for <em>path</em> to the server set by <a href="#setHost">setHost</a>()
or as specified in the constructor.
<p> <em>path</em> must be an absolute path like <tt>/index.html</tt> or an
absolute URI like <a href="http://www.trolltech.com/index.html">http://www.trolltech.com/index.html</a>.
<p> The function does not block and returns immediately. The request
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#requestStarted">requestStarted</a>() and <a href="#requestFinished">requestFinished</a>().
<p> When the request is started the requestStarted() signal is
emitted. When it is finished the requestFinished() signal is
emitted.
<p> <p>See also <a href="#setHost">setHost</a>(), <a href="#get">get</a>(), <a href="#post">post</a>(), <a href="#request">request</a>(), <a href="#requestStarted">requestStarted</a>(), <a href="#requestFinished">requestFinished</a>(), and <a href="#done">done</a>().

<h3 class=fn>int <a name="post"></a>TQHttp::post ( const&nbsp;<a href="ntqstring.html">TQString</a>&nbsp;&amp;&nbsp;path, <a href="ntqiodevice.html">TQIODevice</a>&nbsp;*&nbsp;data, <a href="ntqiodevice.html">TQIODevice</a>&nbsp;*&nbsp;to = 0 )
</h3>
Sends a post request for <em>path</em> to the server set by <a href="#setHost">setHost</a>() or
as specified in the constructor.
<p> <em>path</em> must be an absolute path like <tt>/index.html</tt> or an
absolute URI like <a href="http://www.trolltech.com/index.html">http://www.trolltech.com/index.html</a>.
<p> The incoming data comes via the <em>data</em> IO device.
<p> If the IO device <em>to</em> is 0 the <a href="#readyRead">readyRead</a>() signal is emitted
every time new content data is available to read.
<p> If the IO device <em>to</em> is not 0, the content data of the response
is written directly to the device. Make sure that the <em>to</em>
pointer is valid for the duration of the operation (it is safe to
delete it when the <a href="#requestFinished">requestFinished</a>() signal is emitted).
<p> The function does not block and returns immediately. The request
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#requestStarted">requestStarted</a>() and requestFinished().
<p> When the request is started the requestStarted() signal is
emitted. When it is finished the requestFinished() signal is
emitted.
<p> <p>See also <a href="#setHost">setHost</a>(), <a href="#get">get</a>(), <a href="#head">head</a>(), <a href="#request">request</a>(), <a href="#requestStarted">requestStarted</a>(), <a href="#requestFinished">requestFinished</a>(), and <a href="#done">done</a>().

<h3 class=fn>int <a name="post-2"></a>TQHttp::post ( const&nbsp;<a href="ntqstring.html">TQString</a>&nbsp;&amp;&nbsp;path, const&nbsp;<a href="qbytearray.html">TQByteArray</a>&nbsp;&amp;&nbsp;data, <a href="ntqiodevice.html">TQIODevice</a>&nbsp;*&nbsp;to = 0 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <em>data</em> is used as the content data of the HTTP request.

<h3 class=fn><a href="qbytearray.html">TQByteArray</a> <a name="readAll"></a>TQHttp::readAll ()
</h3>
Reads all the bytes from the response content and returns them.
<p> <p>See also <a href="#get">get</a>(), <a href="#post">post</a>(), <a href="#request">request</a>(), <a href="#readyRead">readyRead</a>(), <a href="#bytesAvailable">bytesAvailable</a>(), and <a href="#readBlock">readBlock</a>().

<h3 class=fn>TQ_LONG <a name="readBlock"></a>TQHttp::readBlock ( char&nbsp;*&nbsp;data, TQ_ULONG&nbsp;maxlen )
</h3>
Reads <em>maxlen</em> bytes from the response content into <em>data</em> and
returns the number of bytes read. Returns -1 if an error occurred.
<p> <p>See also <a href="#get">get</a>(), <a href="#post">post</a>(), <a href="#request">request</a>(), <a href="#readyRead">readyRead</a>(), <a href="#bytesAvailable">bytesAvailable</a>(), and <a href="#readAll">readAll</a>().

<h3 class=fn>void <a name="readyRead"></a>TQHttp::readyRead ( const&nbsp;<a href="qhttpresponseheader.html">TQHttpResponseHeader</a>&nbsp;&amp;&nbsp;resp )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when there is new response data to read.
<p> If you specified a device in the request where the data should be
written to, then this signal is <em>not</em> emitted; instead the data
is written directly to the device.
<p> The response header is passed in <em>resp</em>.
<p> You can read the data with the <a href="#readAll">readAll</a>() or <a href="#readBlock">readBlock</a>() functions
<p> This signal is useful if you want to process the data in chunks as
soon as it becomes available. If you are only interested in the
complete data, just connect to the <a href="#requestFinished">requestFinished</a>() signal and
read the data then instead.
<p> <p>See also <a href="#get">get</a>(), <a href="#post">post</a>(), <a href="#request">request</a>(), <a href="#readAll">readAll</a>(), <a href="#readBlock">readBlock</a>(), and <a href="#bytesAvailable">bytesAvailable</a>().

<h3 class=fn>int <a name="request"></a>TQHttp::request ( const&nbsp;<a href="qhttprequestheader.html">TQHttpRequestHeader</a>&nbsp;&amp;&nbsp;header, <a href="ntqiodevice.html">TQIODevice</a>&nbsp;*&nbsp;data = 0, <a href="ntqiodevice.html">TQIODevice</a>&nbsp;*&nbsp;to = 0 )
</h3>
Sends a request to the server set by <a href="#setHost">setHost</a>() or as specified in
the constructor. Uses the <em>header</em> as the HTTP request header.
You are responsible for setting up a header that is appropriate
for your request.
<p> The incoming data comes via the <em>data</em> IO device.
<p> If the IO device <em>to</em> is 0 the <a href="#readyRead">readyRead</a>() signal is emitted
every time new content data is available to read.
<p> If the IO device <em>to</em> is not 0, the content data of the response
is written directly to the device. Make sure that the <em>to</em>
pointer is valid for the duration of the operation (it is safe to
delete it when the <a href="#requestFinished">requestFinished</a>() signal is emitted).
<p> The function does not block and returns immediately. The request
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#requestStarted">requestStarted</a>() and requestFinished().
<p> When the request is started the requestStarted() signal is
emitted. When it is finished the requestFinished() signal is
emitted.
<p> <p>See also <a href="#setHost">setHost</a>(), <a href="#get">get</a>(), <a href="#post">post</a>(), <a href="#head">head</a>(), <a href="#requestStarted">requestStarted</a>(), <a href="#requestFinished">requestFinished</a>(), and <a href="#done">done</a>().

<h3 class=fn>int <a name="request-2"></a>TQHttp::request ( const&nbsp;<a href="qhttprequestheader.html">TQHttpRequestHeader</a>&nbsp;&amp;&nbsp;header, const&nbsp;<a href="qbytearray.html">TQByteArray</a>&nbsp;&amp;&nbsp;data, <a href="ntqiodevice.html">TQIODevice</a>&nbsp;*&nbsp;to = 0 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <em>data</em> is used as the content data of the HTTP request.

<h3 class=fn>void <a name="requestFinished"></a>TQHttp::requestFinished ( int&nbsp;id, bool&nbsp;error )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when processing the request identified by
<em>id</em> has finished. <em>error</em> is TRUE if an error occurred during
the processing; otherwise <em>error</em> is FALSE.
<p> <p>See also <a href="#requestStarted">requestStarted</a>(), <a href="#done">done</a>(), <a href="#error">error</a>(), and <a href="#errorString">errorString</a>().

<h3 class=fn>void <a name="requestStarted"></a>TQHttp::requestStarted ( int&nbsp;id )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when processing the request identified by
<em>id</em> starts.
<p> <p>See also <a href="#requestFinished">requestFinished</a>() and <a href="#done">done</a>().

<h3 class=fn>void <a name="responseHeaderReceived"></a>TQHttp::responseHeaderReceived ( const&nbsp;<a href="qhttpresponseheader.html">TQHttpResponseHeader</a>&nbsp;&amp;&nbsp;resp )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when the HTTP header of a server response
is available. The header is passed in <em>resp</em>.
<p> <p>See also <a href="#get">get</a>(), <a href="#post">post</a>(), <a href="#head">head</a>(), <a href="#request">request</a>(), and <a href="#readyRead">readyRead</a>().

<h3 class=fn>int <a name="setHost"></a>TQHttp::setHost ( const&nbsp;<a href="ntqstring.html">TQString</a>&nbsp;&amp;&nbsp;hostname, TQ_UINT16&nbsp;port = 80 )
</h3>
Sets the HTTP server that is used for requests to <em>hostname</em> on
port <em>port</em>.
<p> The function does not block and returns immediately. The request
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#requestStarted">requestStarted</a>() and <a href="#requestFinished">requestFinished</a>().
<p> When the request is started the requestStarted() signal is
emitted. When it is finished the requestFinished() signal is
emitted.
<p> <p>See also <a href="#get">get</a>(), <a href="#post">post</a>(), <a href="#head">head</a>(), <a href="#request">request</a>(), <a href="#requestStarted">requestStarted</a>(), <a href="#requestFinished">requestFinished</a>(), and <a href="#done">done</a>().

<h3 class=fn><a href="ntqhttp.html#State-enum">State</a> <a name="state"></a>TQHttp::state () const
</h3>
Returns the current state of the object. When the state changes,
the <a href="#stateChanged">stateChanged</a>() signal is emitted.
<p> <p>See also <a href="#State-enum">State</a> and <a href="#stateChanged">stateChanged</a>().

<h3 class=fn>void <a name="stateChanged"></a>TQHttp::stateChanged ( int&nbsp;state )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when the state of the TQHttp object changes.
The argument <em>state</em> is the new state of the connection; it is
one of the <a href="#State-enum">State</a> values.
<p> This usually happens when a request is started, but it can also
happen when the server closes the connection or when a call to
<a href="#closeConnection">closeConnection</a>() succeeded.
<p> <p>See also <a href="#get">get</a>(), <a href="#post">post</a>(), <a href="#head">head</a>(), <a href="#request">request</a>(), <a href="#closeConnection">closeConnection</a>(), <a href="#state">state</a>(), and <a href="#State-enum">State</a>.

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">TQt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>TQt 3.3.8</div>
</table></div></address></body>
</html>
